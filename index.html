<!DOCTYPE html>
<html>
<head>
  <title>Мозаика с текстурами</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    :root {
      --primary-color: #9b9ad7;
      --primary-hover: #7c0591;
      --secondary-color: #f8f9fa;
      --text-color: #333;
      --text-light: #666;
      --border-color: #e0e0e0;
      --bg-color: #f5f7fa;
      --panel-bg: #fffefb;
      --shadow-sm: 0 1px 3px rgba(0,0,0,0.1);
      --shadow-md: 0 4px 6px rgba(0,0,0,0.1);
      --shadow-lg: 0 10px 25px rgba(0,0,0,0.1);
      --radius-sm: 4px;
      --radius-md: 8px;
      --radius-lg: 12px;
      --transition: all 0.2s ease;
      --context-menu-text: #666; /* Цвет текста контекстного меню */
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      margin: 0;
      font-family: 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', sans-serif;
      background: var(--bg-color);
      color: var(--text-color);
      display: flex;
      height: 100vh;
      overflow: hidden;
    }

    /* Текстуры панель */
    .textures-panel {
      position: relative;
      width: 280px;
      background: var(--panel-bg);
      border-right: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      z-index: 10;
    }

    .textures-header h3 {
      text-align: center; /* Выравнивание текста по центру */
      margin-bottom: 8px; /* Отступ снизу (уже есть в вашем коде) */
    }

    .textures-header {
      padding: 12px 16px;
      border-bottom: 1px solid var(--border-color);
    }

    .textures-header h3 {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .texture-filters {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      padding: 0 16px 12px;
    }

    .texture-filters select,
    .texture-filters input {
      width: 100%;
      padding: 8px 10px;
      border: 1px solid var(--border-color);
      border-radius: var(--radius-sm);
      font-size: 13px;
      background: var(--panel-bg);
      color: var(--text-color);
      transition: var(--transition);
    }

    .texture-filters select:focus,
    .texture-filters input:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 2px rgba(67, 97, 238, 0.2);
    }

    .texture-filters input {
      grid-column: span 2;
    }

    .textures-container {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
    }

    .textures-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 16px;
    }

    .texture-thumb {
      cursor: pointer;
      border: 2px solid transparent;
      border-radius: 50%;
      overflow: hidden;
      transition: var(--transition);
      background: var(--panel-bg);
      box-shadow: var(--shadow-sm);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 8px;
    }

    .texture-thumb:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
      border-color: rgba(67, 97, 238, 0.3);
    }

    .texture-thumb.active {
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.2);
    }

    .texture-thumb img {
      width: 80px;
      height: 80px;
      object-fit: cover;
      border-radius: 50%;
    }

    .texture-info {
      font-size: 12px;
      padding: 6px;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      color: var(--text-light);
      width: 100%;
    }

    .textures-footer {
      padding: 12px 16px;
      border-top: 1px solid var(--border-color);
      display: flex;
      gap: 8px;
    }

    /* Основное содержимое */
    .main-content {
      padding-top: 72px;
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }

    /* Панель инструментов */
    /* .tools-panel {
      padding: 8px 16px;
      background: var(--panel-bg);
      border-bottom: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      z-index: 20;
      position: sticky;
      top: 0;
      min-height: 72px;
    } */


    .tools-panel {
      padding: 8px 16px;
      background: var(--panel-bg);
      border-bottom: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      z-index: 20;
      position: fixed; /* Изменено с sticky на fixed */
      top: 0;
      left: 280px; /* Ширина панели текстур */
      right: 0; /* Растягиваем до правого края */
      min-height: 72px;
    }


    .tool-group {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: var(--radius-md);
      background: var(--panel-bg);
      border: 1px solid var(--border-color);
    }

    .tool-group.compact {
      padding: 4px 8px;
    }

    .tool-group.vertical {
      flex-direction: column;
      align-items: flex-start;
    }

    .tool-label {
      font-size: 12px;
      color: var(--text-light);
      white-space: nowrap;
    }

    /* Кнопки */
    button {
      background: var(--primary-color);
      color: white;
      border: none;
      border-radius: var(--radius-sm);
      padding: 8px 12px;
      cursor: pointer;
      transition: var(--transition);
      font-size: 13px;
      font-family: inherit;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    button:hover {
      background: var(--primary-hover);
      transform: translateY(-1px);
      box-shadow: var(--shadow-sm);
    }

    button:active {
      transform: translateY(0);
    }

    button.icon-button {
      width: 32px;
      height: 32px;
      padding: 0;
      border-radius: 50%;
    }

    .icon-button svg {
      width: 16px;
      height: 16px;
    }

    .separator {
      width: 1px;
      height: 24px;
      background: var(--border-color);
    }

    /* Input элементы */
    input[type="range"] {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      width: 80px;
      height: 4px;
      background: var(--border-color);
      border-radius: 2px;
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--primary-color);
      cursor: pointer;
      transition: var(--transition);
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.1);
    }

    input[type="color"] {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 2px solid var(--panel-bg);
      cursor: pointer;
      transition: var(--transition);
    }

    input[type="color"]:hover {
      transform: scale(1.1);
    }

    input[type="number"] {
      width: 70px;
      padding: 6px 8px;
      border: 1px solid var(--border-color);
      border-radius: var(--radius-sm);
      font-size: 13px;
      text-align: center;
    }

    /* Контейнер холста */
    .canvas-container {
      flex: 1;
      position: relative;
      overflow: auto;
      background: #f9f5e8;
      box-shadow: var(--shadow-md) inset;
      /* Новые свойства: */
      display: grid;
      place-items: center; /* Центрируем содержимое */
      padding: 20px; /* Отступы со всех сторон */
      box-sizing: border-box; /* Важно! Чтобы padding не увеличивал размер */
    }

    canvas {
      display: block;
      cursor: pointer;
      background: #f9f5e8;
      box-shadow: var(--shadow-md);
      /* Убираем margin: auto - теперь центрирует контейнер */
    }



    /* Контекстные меню */
    #contextMenu, #shapeContextMenu {
      position: fixed;
      display: none;
      background: var(--panel-bg);
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-lg);
      z-index: 100;
      min-width: 220px;
      padding: 8px 0;
    }

    #contextMenu button, #shapeContextMenu button {
      display: flex;
      width: 100%;
      padding: 10px 16px;
      border: none;
      background: none;
      text-align: left;
      color: var(--context-menu-text);
      border-radius: 0;
      justify-content: flex-start;
    }

    #contextMenu button:hover, #shapeContextMenu button:hover {
      background: rgba(0, 0, 0, 0.05);
    }

    .shape-type {
      font-weight: 500;
      font-size:large;
      margin-right: 8px;
      width: 20px;
      display: inline-block;
      text-align: center;
    }

    /* Управление холстом */
    .canvas-controls {
      display: flex;
      align-items: center;
      gap: 8px;
      position: absolute;
      right: 16px;
      top: 50%;
      transform: translateY(-50%);
      background: var(--panel-bg);
      padding: 6px 10px;
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-sm);
      border: 1px solid var(--border-color);
    }

    /* Переключение между панелями инструментов */
    .tools-main, .tools-texture {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 12px;
    }

    .tools-texture {
      display: none;
    }

    /* Специальные стили для кнопки симметрии */
    .symmetry-btn {
      background: var(--primary-color);
      color: white;
      width: 32px;
      height: 32px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-sm);
    }

    .symmetry-btn.active {
      background: var(--primary-hover);
    }

    .symmetry-btn svg {
      stroke: white;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
      fill: none;
    }

    /* Адаптивность */
    @media (max-width: 1200px) {
      .textures-panel {
        width: 240px;
      }
      .textures-grid {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 992px) {
      .tools-panel {
        padding: 8px;
      }
      .tool-group {
        padding: 4px 6px;
      }
    }

    /* Анимации */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-5px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .texture-thumb {
      animation: fadeIn 0.3s ease forwards;
    }

    .texture-filters select option {
      background: var(--panel-bg); /* Фон пунктов */
      color: var(--text-color); /* Цвет текста */
      padding: 8px; /* Отступы внутри пунктов */
    }
    
  </style>
</head>
<body>
  <div class="textures-panel" id="texturesPanel">
    <div class="textures-header">
      <h3>TEXTURES</h3>
      <div class="texture-filters">
        <select id="colorFilter">
          <option value="">Tone</option>
          <option value="light">Light</option>
          <option value="dark">Dark</option>
          <option value="red">Red</option>
        </select>
        
        <select id="patternFilter">
          <option value="">Style</option>
          <option value="bird-eye">Bird-eye</option>
          <option value="burl">Burl</option>
          <option value="crotch">Crotch</option>
          <option value="curly">Curly</option>
          <option value="figured">Figured</option>
          <option value="flame">Flame</option>
          <option value="pommele">Pommele</option>
          <option value="radial">Radial</option>

        </select>
        
        <input type="text" id="textureSearch" placeholder="search...">
      </div>
    </div>
    
    <div class="textures-container">
      <div class="textures-grid" id="texturesGrid">
        <!-- Текстуры будут загружаться здесь -->
      </div>
    </div>
    
    <div class="textures-footer">
      <input type="file" id="textureUpload" accept="image/*" style="display: none;">
      <button id="addTextureBtn">
        <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M12 5v14M5 12h14" />
        </svg>
        Add
      </button>
    </div>
  </div>

  <div class="main-content">
  
    <div class="tools-panel">
      <div class="tools-main" id="toolsMain">
        <!-- Группа загрузки -->
        <div class="tool-group compact">
          <input type="file" id="imageUpload" accept="image/*" style="display: none;">
          <button id="uploadBtn" title="Загрузить изображение" class="icon-button">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12" />
            </svg>
          </button>
        </div>
        
        <!-- Группа прозрачности -->
        <div class="tool-group vertical">
          <div style="display: flex; align-items: center; gap: 8px;">
            <span class="tool-label">Picture</span>
            <input type="range" id="imageOpacity" min="0" max="100" value="100">
          </div>
          <div style="display: flex; align-items: center; gap: 8px;">
            <span class="tool-label">Mosaic</span>
            <input type="range" id="mosaicOpacity" min="0" max="100" value="100">
          </div>
        </div>
        
        <!-- Группа инструментов -->
        <div class="tool-group compact">
          <button id="symmetry" title="Включить/выключить симметрию" class="symmetry-btn">
            <svg viewBox="0 0 24 24" width="20" height="20">
              <path d="M12 2v20M5 12h14M8 8l-3 4 3 4M16 8l3 4-3 4" />
            </svg>
          </button>
          <span class="tool-label">Line</span>
          <input type="range" id="strokeWidth" min="0.01" max="5" value="1" step = "0.1" style="width: 50px;">
        </div>
        
        <!-- Группа стилей -->
        <div class="tool-group compact">
          <input type="color" id="strokeColor" value="#666666" title="Цвет обводки">
        </div>
        
        <div class="separator"></div>
        
        <!-- Группа действий -->
        <div class="tool-group compact">
          <button id="deleteSelected" title="Удалить выделенное (Del)" class="icon-button">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" />
            </svg>
          </button>
          <button id="undoBtn" title="Отменить (Ctrl+Z)" class="icon-button">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M3 10h10a4 4 0 0 1 0 8H5a4 4 0 0 1-4-4V6a4 4 0 0 1 4-4h3" />
              <path d="M7 2l3 3-3 3" />
            </svg>
          </button>
          <button id="redoBtn" title="Повторить (Ctrl+Y)" class="icon-button">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 10H11a4 4 0 0 0 0 8h8a4 4 0 0 0 4-4V6a4 4 0 0 0-4-4h-3" />
              <path d="M17 2l-3 3 3 3" />
            </svg>
          </button>
        </div>
        
        <div class="separator"></div>
        
        <!-- Группа сохранения -->
        <div class="tool-group compact">
          <button id="saveSVG" title="Сохранить SVG">
            <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M7 10l5 5 5-5M12 15V3" />
            </svg>
            SVG
          </button>
          <button id="savePNG" title="Сохранить PNG">
            <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2v-4M7 10l5 5 5-5M12 15V3" />
            </svg>
            PNG
          </button>
        </div>
      </div>
      
      <div class="tools-texture" id="toolsTexture">
        <!-- Инструменты для работы с текстурами -->
        <div class="tool-group">
          <label class="tool-label">Масштаб</label>
          <input type="range" id="textureScale" min="10" max="500" value="100">
        </div>
        <div class="tool-group">
          <label class="tool-label">Поворот</label>
          <input type="range" id="textureRotation" min="0" max="360" value="0">
        </div>
        <div class="tool-group">
          <label class="tool-label">Смещение X</label>
          <input type="range" id="textureOffsetX" min="-200" max="200" value="0">
        </div>
        <div class="tool-group">
          <label class="tool-label">Смещение Y</label>
          <input type="range" id="textureOffsetY" min="-200" max="200" value="0">
        </div>
        <div class="tool-group compact">
          <button id="flipTextureX">Отразить X</button>
          <button id="flipTextureY">Отразить Y</button>
        </div>
        <div class="tool-group compact">
          <button id="resetTextureBtn">Сбросить</button>
          <button id="removeTextureBtn">Удалить</button>
        </div>
        <button id="backToMainTools" class="icon-button" title="Назад к основным инструментам">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M19 12H5M12 19l-7-7 7-7" />
          </svg>
        </button>
      </div>

      <!-- Вынесенные настройки холста (справа) -->
      <div class="canvas-controls" id="canvasControls">
          <span class="tool-label">↔</span>
          <input type="number" id="canvasWidth" class="canvas-size-input" value="1200" min="100" step="50">
          <span class="tool-label">↕</span>
          <input type="number" id="canvasHeight" class="canvas-size-input" value="800" min="100" step="50">
          <input type="color" id="backgroundColor" value="#fffdf5" title="Цвет фона">
          <button id="applyCanvasSize" class="icon-button">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M5 13l4 4L19 7" />
            </svg>
          </button>
      </div>
    </div>


    <div class="canvas-container">
      <div id="contextMenu">
        <div class="tool-group vertical" style="border: none; padding: 8px;">
          <label class="tool-label">Размер фигуры:</label>
          <input type="range" id="shapeSize" min="20" max="100" value="40" style="width: 100%; margin: 8px 0;">
        </div>
        <button id="addTriangle"><span class="shape-type">▲</span>Добавить треугольник</button>
        <button id="addSquare"><span class="shape-type">■</span>Добавить квадрат</button>
        <button id="addHexagon"><span class="shape-type">⬢</span>Добавить шестиугольник</button>
      </div>
      
      <div id="shapeContextMenu">
        <button id="splitIntoTriangles"><span class="shape-type">🔺</span>Разделить на треугольники</button>
        <button id="splitIntoSimilar"><span class="shape-type">🔺🔺</span>Разделить на подобные</button>
        <button id="addTextureToShape"><span class="shape-type">🎨</span>Добавить текстуру</button>
      </div>

      <canvas id="canvas"></canvas>
    </div>
  </div>

  <script>
    // Основные переменные
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const contextMenu = document.getElementById('contextMenu');
    const shapeContextMenu = document.getElementById('shapeContextMenu');
    const addTriangleBtn = document.getElementById('addTriangle');
    const addSquareBtn = document.getElementById('addSquare');
    const addHexagonBtn = document.getElementById('addHexagon');
    const splitIntoTrianglesBtn = document.getElementById('splitIntoTriangles');
    const splitIntoSimilarBtn = document.getElementById('splitIntoSimilar');
    const addTextureToShapeBtn = document.getElementById('addTextureToShape');
    const symmetryBtn = document.getElementById('symmetry');
    const imageUpload = document.getElementById('imageUpload');
    const uploadBtn = document.getElementById('uploadBtn');
    const imageOpacityInput = document.getElementById('imageOpacity');
    const mosaicOpacityInput = document.getElementById('mosaicOpacity');
    const shapeSizeInput = document.getElementById('shapeSize');
    const strokeColorInput = document.getElementById('strokeColor');
    const strokeWidthInput = document.getElementById('strokeWidth');
    const deleteSelectedBtn = document.getElementById('deleteSelected');
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');
    const saveSVGBtn = document.getElementById('saveSVG');
    const savePNGBtn = document.getElementById('savePNG');
    const textureUpload = document.getElementById('textureUpload');
    const addTextureBtn = document.getElementById('addTextureBtn');
    const colorFilter = document.getElementById('colorFilter');
    const patternFilter = document.getElementById('patternFilter');
    const textureSearch = document.getElementById('textureSearch');
    const texturesGrid = document.getElementById('texturesGrid');
    const textureScale = document.getElementById('textureScale');
    const textureRotation = document.getElementById('textureRotation');
    const textureOffsetX = document.getElementById('textureOffsetX');
    const textureOffsetY = document.getElementById('textureOffsetY');
    const flipTextureX = document.getElementById('flipTextureX');
    const flipTextureY = document.getElementById('flipTextureY');
    const resetTextureBtn = document.getElementById('resetTextureBtn');
    const removeTextureBtn = document.getElementById('removeTextureBtn');
    const backToMainToolsBtn = document.getElementById('backToMainTools');
    
    const canvasWidthInput = document.getElementById('canvasWidth');
    const canvasHeightInput = document.getElementById('canvasHeight');
    const applyCanvasSizeBtn = document.getElementById('applyCanvasSize');
    const backgroundColorInput = document.getElementById('backgroundColor');
    const toolsMain = document.getElementById('toolsMain');
    const toolsTexture = document.getElementById('toolsTexture');
    const canvasControls = document.getElementById('canvasControls');

    // Настройки
    let canvasWidth = 1200;
    let canvasHeight = 800;
    let canvasOffsetX = 0;
    let canvasOffsetY = 0;
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    const shapes = [];
    const symmetricPairs = new Map();
    let isSymmetryMode = false;
    let dragMode = null;
    let activeShape = null;
    let menuPosition = { x: 0, y: 0 };
    let backgroundImage = null;
    let selectionStart = null;
    let lastMousePosition = { x: 0, y: 0 };
    let clickedShape = null;
    let ctrlPressed = false;
    const SNAP_DISTANCE = 10;
    const VERTEX_HIT_RADIUS = 15;

    // История действий
    const history = {
      states: [],
      currentIndex: -1,
      maxStates: 20,
      
      saveState() {
        this.states = this.states.slice(0, this.currentIndex + 1);
        
        const state = {
          shapes: shapes.map(shape => ({
            ...shape,
            vertices: [...shape.vertices.map(v => ({...v}))],
            isSelected: shape.isSelected,
            texture: shape.texture,
            textureScale: shape.textureScale,
            textureRotation: shape.textureRotation,
            textureOffsetX: shape.textureOffsetX,
            textureOffsetY: shape.textureOffsetY,
            textureFlipX: shape.textureFlipX,
            textureFlipY: shape.textureFlipY
          })),
          symmetricPairs: Array.from(symmetricPairs.entries()).map(([key, value]) => [key.id, value.id])
        };
        
        this.states.push(JSON.parse(JSON.stringify(state)));
        if (this.states.length > this.maxStates) {
          this.states.shift();
        } else {
          this.currentIndex = this.states.length - 1;
        }
        
        this.updateButtons();
      },
      
      undo() {
        if (this.currentIndex <= 0) return;
        this.currentIndex--;
        this.restoreState();
      },
      
      redo() {
        if (this.currentIndex >= this.states.length - 1) return;
        this.currentIndex++;
        this.restoreState();
      },
      
      restoreState() {
        if (this.currentIndex < 0 || this.currentIndex >= this.states.length) return;
        
        const state = this.states[this.currentIndex];
        shapes.length = 0;
        symmetricPairs.clear();
        
        state.shapes.forEach(s => {
          const shape = new Shape(s.x, s.y, s.vertices, s.id);
          shape.color = s.color;
          shape.isSelected = s.isSelected;
          shape.texture = s.texture;
          shape.textureScale = s.textureScale;
          shape.textureRotation = s.textureRotation;
          shape.textureOffsetX = s.textureOffsetX;
          shape.textureOffsetY = s.textureOffsetY;
          shape.textureFlipX = s.textureFlipX;
          shape.textureFlipY = s.textureFlipY;
          
          if (shape.texture) {
            const texture = textureManager.getTextureByName(shape.texture);
            if (texture) {
              shape.textureImage = texture.img;
            }
          }
          
          shapes.push(shape);
        });
        
        state.symmetricPairs.forEach(([keyId, valueId]) => {
          const shape1 = shapes.find(s => s.id === keyId);
          const shape2 = shapes.find(s => s.id === valueId);
          if (shape1 && shape2) {
            symmetricPairs.set(shape1, shape2);
            symmetricPairs.set(shape2, shape1);
          }
        });
        
        render();
        this.updateButtons();
      },
      
      updateButtons() {
        undoBtn.disabled = this.currentIndex <= 0;
        redoBtn.disabled = this.currentIndex >= this.states.length - 1;
      }
    };

    // Класс фигуры
    class Shape {
      constructor(x, y, vertices, id = Date.now() + Math.random()) {
        this.id = id;
        this.x = x;
        this.y = y;
        this.vertices = vertices;
        this.color = '#d2b48c'; // Простой бежевый цвет вместо градиента
        this.isDragging = false;
        this.dragVertex = null;
        this.isSelected = false;
        this.vertexOffsets = null;
        this.texture = null;
        this.textureImage = null;
        this.textureScale = 100;
        this.textureRotation = 0;
        this.textureOffsetX = 0;
        this.textureOffsetY = 0;
        this.textureFlipX = false;
        this.textureFlipY = false;
      }

      updateColor() {
        if (!backgroundImage) return;
        
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        const tempCtx = tempCanvas.getContext('2d');
        
        // Рисуем изображение с учетом смещения
        tempCtx.drawImage(backgroundImage, canvasOffsetX, canvasOffsetY);
        
        // Создаем маску для фигуры
        tempCtx.globalCompositeOperation = 'destination-in';
        tempCtx.fillStyle = 'black';
        tempCtx.beginPath();
        tempCtx.moveTo(this.x + this.vertices[0].x, this.y + this.vertices[0].y);
        for (let i = 1; i < this.vertices.length; i++) {
          tempCtx.lineTo(this.x + this.vertices[i].x, this.y + this.vertices[i].y);
        }
        tempCtx.closePath();
        tempCtx.fill();
        
        // Получаем данные пикселей
        const pixelData = tempCtx.getImageData(0, 0, canvas.width, canvas.height).data;
        let r = 0, g = 0, b = 0, count = 0;
        
        for (let i = 0; i < pixelData.length; i += 4) {
          if (pixelData[i+3] > 0) {
            r += pixelData[i];
            g += pixelData[i+1];
            b += pixelData[i+2];
            count++;
          }
        }
        
        if (count > 0) {
          this.color = `rgb(${Math.round(r/count)}, ${Math.round(g/count)}, ${Math.round(b/count)})`;
        }
      }

      hitTestVertex(x, y) {
        for (let i = 0; i < this.vertices.length; i++) {
          const vx = this.x + this.vertices[i].x;
          const vy = this.y + this.vertices[i].y;
          const distance = Math.sqrt((x - vx) ** 2 + (y - vy) ** 2);
          
          if (distance < VERTEX_HIT_RADIUS) return i;
        }
        return null;
      }

      hitTestEdge(x, y, threshold = 10) {
        for (let i = 0; i < this.vertices.length; i++) {
          const j = (i + 1) % this.vertices.length;
          const x1 = this.x + this.vertices[i].x;
          const y1 = this.y + this.vertices[i].y;
          const x2 = this.x + this.vertices[j].x;
          const y2 = this.y + this.vertices[j].y;
          
          const distance = distanceToLine(x, y, x1, y1, x2, y2);
          if (distance < threshold) {
            return { 
              edgeIndex: i,
              position: { 
                x: (x1 + x2) / 2 - this.x, 
                y: (y1 + y2) / 2 - this.y 
              }
            };
          }
        }
        return null;
      }

      contains(x, y) {
        const points = this.vertices.map(v => ({
          x: this.x + v.x,
          y: this.y + v.y
        }));
        let inside = false;
        for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
          const xi = points[i].x, yi = points[i].y;
          const xj = points[j].x, yj = points[j].y;
          const intersect = ((yi > y) !== (yj > y)) &&
            (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
          if (intersect) inside = !inside;
        }
        return inside;
      }

      drawTexture() {
        if (!this.texture || !this.textureImage) return;
        
        ctx.save();
        
        // Создаем путь для фигуры
        ctx.beginPath();
        ctx.moveTo(this.x + this.vertices[0].x, this.y + this.vertices[0].y);
        for (let i = 1; i < this.vertices.length; i++) {
          ctx.lineTo(this.x + this.vertices[i].x, this.y + this.vertices[i].y);
        }
        ctx.closePath();
        ctx.clip();
        
        // Вычисляем центр фигуры
        let centerX = 0, centerY = 0;
        this.vertices.forEach(v => {
          centerX += this.x + v.x;
          centerY += this.y + v.y;
        });
        centerX /= this.vertices.length;
        centerY /= this.vertices.length;
        
        // Применяем трансформации к текстуре
        ctx.translate(centerX, centerY);
        ctx.rotate(this.textureRotation * Math.PI / 180);
        
        // Вычисляем размеры текстуры с учетом масштаба
        const scale = this.textureScale / 100;
        const width = this.textureImage.width * scale;
        const height = this.textureImage.height * scale;
        
        // Отражаем относительно центра фигуры
        if (this.textureFlipX || this.textureFlipY) {
          ctx.scale(
            this.textureFlipX ? -1 : 1,
            this.textureFlipY ? -1 : 1
          );
        }
        
        // Рисуем текстуру с учетом смещения
        ctx.drawImage(
          this.textureImage, 
          -width/2 + this.textureOffsetX, 
          -height/2 + this.textureOffsetY, 
          width, 
          height
        );
        
        ctx.restore();
      }

      draw() {
        if (this.texture && this.textureImage) {
          ctx.globalAlpha = parseInt(mosaicOpacityInput.value) / 100;
          this.drawTexture();
        } else {
          // Обновляем цвет только если есть фоновое изображение
          if (backgroundImage) {
            this.updateColor();
          }
          
          ctx.globalAlpha = parseInt(mosaicOpacityInput.value) / 100;
          ctx.fillStyle = this.color;

          ctx.beginPath();
          ctx.moveTo(this.x + this.vertices[0].x, this.y + this.vertices[0].y);
          for (let i = 1; i < this.vertices.length; i++) {
            ctx.lineTo(this.x + this.vertices[i].x, this.y + this.vertices[i].y);
          }
          ctx.closePath();
          ctx.fill();
        }
        
        // Обводка
        if (this.isSelected) {
          ctx.strokeStyle = '#77aaff';
        } else {
          ctx.strokeStyle = strokeColorInput.value;
        }
        ctx.lineWidth = strokeWidthInput.value;
        ctx.stroke();
        ctx.globalAlpha = 1;

        // Вершины (только для выделенной фигуры)
        if (this.isSelected) {
          ctx.fillStyle = '#31d';
          this.vertices.forEach(v => {
            ctx.beginPath();
            ctx.arc(this.x + v.x, this.y + v.y, 2, 0, Math.PI * 2);
            ctx.fill();
          });
        }
      }
    }

    // Менеджер текстур
    class TextureManager {
      constructor() {
        this.textures = [];
        this.loadDefaultTextures();
      }

      loadDefaultTextures() {
        // Локальные текстуры из папки textures
        const defaultTextures = [
          { name: 'amboyna', color: 'dark', pattern: 'burl', file: 'amboyna.dark.burl.01.png' },
          { name: 'amboyna', color: 'dark', pattern: 'burl', file: 'amboyna.dark.burl.02.png' },
          { name: 'amboyna', color: 'dark', pattern: 'burl', file: 'amboyna.dark.burl.03.png' },
          { name: 'amboyna', color: 'dark', pattern: 'burl', file: 'amboyna.dark.burl.04.png' },
          { name: 'angelim', color: 'dark', pattern: 'radial', file: 'angelim.dark.radial.01.png' },
          { name: 'angelim', color: 'dark', pattern: 'radial', file: 'angelim.dark.radial.02.png' },
          { name: 'angelim', color: 'dark', pattern: 'radial', file: 'angelim.dark.radial.03.png' },
          { name: 'anigre', color: 'light', pattern: 'bird-eye', file: 'anigre.light.bird-eye.01.png' },
          { name: 'anigre', color: 'light', pattern: 'bird-eye', file: 'anigre.light.bird-eye.02.png' },
          { name: 'anigre', color: 'light', pattern: 'bird-eye', file: 'anigre.light.bird-eye.03.png' },
          { name: 'anigre', color: 'light', pattern: 'bird-eye', file: 'anigre.light.bird-eye.04.png' },
          { name: 'anigre', color: 'light', pattern: 'curly', file: 'anigre.light.curly.01.png' },
          { name: 'anigre', color: 'light', pattern: 'curly', file: 'anigre.light.curly.02.png' },
          { name: 'anigre', color: 'light', pattern: 'curly', file: 'anigre.light.curly.03.png' },
          { name: 'anigre', color: 'light', pattern: 'curly', file: 'anigre.light.curly.04.png' },
          { name: 'ash', color: 'light', pattern: 'burl', file: 'ash.light.burl.01.png' },
          { name: 'ash', color: 'light', pattern: 'burl', file: 'ash.light.burl.02.png' },
          { name: 'avodire', color: 'dark', pattern: 'crotch', file: 'avodire.dark.crotch.01.png' },
          { name: 'avodire', color: 'dark', pattern: 'crotch', file: 'avodire.dark.crotch.02.png' },
          { name: 'birch', color: 'light', pattern: 'figured', file: 'birch.light.figured.01.png' },
          { name: 'birch', color: 'light', pattern: 'figured', file: 'birch.light.figured.02.png' },
          { name: 'birch', color: 'light', pattern: 'figured', file: 'birch.light.figured.03.png' },
          { name: 'birch', color: 'light', pattern: 'figured', file: 'birch.light.figured.04.png' },
          { name: 'bocote', color: 'dark', pattern: 'radial', file: 'bocote.dark.radial.01.png' },
          { name: 'bocote', color: 'dark', pattern: 'radial', file: 'bocote.dark.radial.02.png' },
          { name: 'bocote', color: 'dark', pattern: 'radial', file: 'bocote.dark.radial.03.png' },
          { name: 'limba', color: 'light', pattern: 'radial', file: 'limba.light.radial.01.png' },
          { name: 'limba', color: 'light', pattern: 'radial', file: 'limba.light.radial.02.png' },
          { name: 'limba', color: 'light', pattern: 'radial', file: 'limba.light.radial.03.png' },
          { name: 'limba', color: 'light', pattern: 'radial', file: 'limba.light.radial.04.png' }
        ];

        // Загружаем каждую текстуру
        defaultTextures.forEach(texture => {
          const img = new Image();
          img.onload = () => {
            this.textures.push({
              name: texture.name,
              color: texture.color,
              pattern: texture.pattern,
              file: texture.file,
              img: img
            });
            this.renderTextures();
          };
          // Указываем относительный путь к текстуре
          img.src = 'textures/' + texture.file;
        });
      }

      addTexture(file) {
        return new Promise((resolve) => {
          const reader = new FileReader();
          reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
              const fileName = file.name.split('.')[0];
              const parts = fileName.split('.');
              const name = parts[0] || 'texture';
              const color = parts.length > 1 ? parts[1] : 'unknown';
              const pattern = parts.length > 2 ? parts[2] : 'unknown';
              
              const texture = {
                name: name,
                color: color,
                pattern: pattern,
                file: file.name,
                img: img
              };
              
              this.textures.push(texture);
              this.renderTextures();
              resolve(texture);
            };
            img.src = event.target.result;
          };
          reader.readAsDataURL(file);
        });
      }

      getTextureByName(name) {
        return this.textures.find(t => t.file === name);
      }

      renderTextures(filter = {}) {
        texturesGrid.innerHTML = '';

        const filtered = this.textures.filter(texture => {
          return (!filter.color || texture.color === filter.color) &&
                 (!filter.pattern || texture.pattern === filter.pattern) &&
                 (!filter.search || texture.file.toLowerCase().includes(filter.search.toLowerCase()));
        });

        filtered.forEach(texture => {
          const thumb = document.createElement('div');
          thumb.className = 'texture-thumb';
          thumb.innerHTML = `
            <img src="${texture.img.src}" 
                 data-texture="${texture.file}"
                 title="${texture.file}">
            <div class="texture-info">${texture.name}</div>
          `;
          
          thumb.addEventListener('click', () => {
            document.querySelectorAll('.texture-thumb').forEach(t => t.classList.remove('active'));
            thumb.classList.add('active');
            
            const selectedShapes = shapes.filter(s => s.isSelected);
            if (selectedShapes.length > 0) {
              selectedShapes.forEach(shape => {
                shape.texture = texture.file;
                shape.textureImage = texture.img;
                shape.textureScale = 100;
                shape.textureRotation = 0;
                shape.textureOffsetX = 0;
                shape.textureOffsetY = 0;
                shape.textureFlipX = false;
                shape.textureFlipY = false;
              });
              
              // Обновляем контролы
              textureScale.value = 100;
              textureRotation.value = 0;
              textureOffsetX.value = 0;
              textureOffsetY.value = 0;
              
              // Показываем панель управления текстурами
              showTextureTools();
              render();
            }
          });
          
          texturesGrid.appendChild(thumb);
        });
      }
    }

    // Инициализация менеджера текстур
    const textureManager = new TextureManager();

    // Генерация фигур
    function generateTriangleVertices(size = 40) {
      const height = size * Math.sqrt(3) / 2;
      return [
        { x: 0, y: -height/2 },
        { x: -size/2, y: height/2 },
        { x: size/2, y: height/2 }
      ];
    }

    function generateSquareVertices(size = 40) {
      const half = size / 2;
      return [
        { x: -half, y: -half },
        { x: half, y: -half },
        { x: half, y: half },
        { x: -half, y: half }
      ];
    }

    function generateHexagonVertices(size = 40) {
      const vertices = [];
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 3) * i;
        vertices.push({
          x: Math.cos(angle) * size,
          y: Math.sin(angle) * size
        });
      }
      return vertices;
    }

    // Вспомогательные функции
    function distanceToLine(x, y, x1, y1, x2, y2) {
      const A = x - x1;
      const B = y - y1;
      const C = x2 - x1;
      const D = y2 - y1;

      const dot = A * C + B * D;
      const lenSq = C * C + D * D;
      let param = -1;
      if (lenSq !== 0) param = dot / lenSq;

      let xx, yy;

      if (param < 0) {
        xx = x1;
        yy = y1;
      }
      else if (param > 1) {
        xx = x2;
        yy = y2;
      }
      else {
        xx = x1 + param * C;
        yy = y1 + param * D;
      }

      return Math.sqrt((x - xx) ** 2 + (y - yy) ** 2);
    }

    function drawSymmetryAxis() {
      if (!isSymmetryMode) return;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2, 0);
      ctx.lineTo(canvas.width / 2, canvas.height);
      ctx.strokeStyle = 'red';
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function createSymmetricPair(x, y, vertices) {
      const shape1 = new Shape(x, y, vertices);
      const mirroredVertices = vertices.map(v => ({ x: -v.x, y: v.y }));
      const shape2 = new Shape(canvas.width - x, y, mirroredVertices);
      
      shapes.push(shape1, shape2);
      symmetricPairs.set(shape1, shape2);
      symmetricPairs.set(shape2, shape1);
    }

    function findConnectedVertices(shape, vertexIndex) {
      const result = [{shape, vertexIndex}];
      const originalX = shape.x + shape.vertices[vertexIndex].x;
      const originalY = shape.y + shape.vertices[vertexIndex].y;
      
      shapes.forEach(otherShape => {
        if (otherShape === shape) return;
        
        otherShape.vertices.forEach((v, i) => {
          const vx = otherShape.x + v.x;
          const vy = otherShape.y + v.y;
          const distance = Math.sqrt(
            Math.pow(originalX - vx, 2) + 
            Math.pow(originalY - vy, 2)
          );
          
          if (distance < SNAP_DISTANCE * 1.5) {
            result.push({shape: otherShape, vertexIndex: i});
          }
        });
      });
      
      return result;
    }

    function snapVertices(shape) {
      const snapThreshold = SNAP_DISTANCE;
      
      shape.vertices.forEach((sv, i) => {
        const shapeVx = shape.x + sv.x;
        const shapeVy = shape.y + sv.y;
        
        shapes.forEach(other => {
          if (other === shape) return;
          
          other.vertices.forEach((ov, j) => {
            const otherVx = other.x + ov.x;
            const otherVy = other.y + ov.y;
            const distance = Math.sqrt(
              Math.pow(shapeVx - otherVx, 2) + 
              Math.pow(shapeVy - otherVy, 2)
            );
            
            if (distance < snapThreshold && shape.isDragging) {
              sv.x = otherVx - shape.x;
              sv.y = otherVy - shape.y;
              
              if (isSymmetryMode && symmetricPairs.has(shape)) {
                const mirror = symmetricPairs.get(shape);
                mirror.vertices[i].x = canvas.width - otherVx - mirror.x;
                mirror.vertices[i].y = otherVy - mirror.y;
              }
            }
          });
        });
      });
    }

    function splitShapeIntoTriangles(shape, pointX, pointY) {
      history.saveState();
      
      const newVertex = {
        x: pointX - shape.x,
        y: pointY - shape.y
      };
      
      const triangles = [];
      for (let i = 0; i < shape.vertices.length; i++) {
        const j = (i + 1) % shape.vertices.length;
        triangles.push({
          vertices: [
            { ...shape.vertices[i] },
            { ...shape.vertices[j] },
            { ...newVertex }
          ]
        });
      }
      
      const index = shapes.indexOf(shape);
      shapes.splice(index, 1);
      
      triangles.forEach(triangle => {
        const newShape = new Shape(shape.x, shape.y, triangle.vertices);
        newShape.color = shape.color;
        newShape.texture = shape.texture;
        newShape.textureImage = shape.textureImage;
        newShape.textureScale = shape.textureScale;
        newShape.textureRotation = shape.textureRotation;
        newShape.textureOffsetX = shape.textureOffsetX;
        newShape.textureOffsetY = shape.textureOffsetY;
        newShape.textureFlipX = shape.textureFlipX;
        newShape.textureFlipY = shape.textureFlipY;
        shapes.push(newShape);
      });
      
      render();
    }

    function splitIntoSimilarTriangles(shape) {
      if (shape.vertices.length !== 3) return; // Работаем только с треугольниками
      
      history.saveState();
      
      const [a, b, c] = shape.vertices;
      
      // Находим середины сторон
      const midAB = {
        x: (a.x + b.x) / 2,
        y: (a.y + b.y) / 2
      };
      const midBC = {
        x: (b.x + c.x) / 2,
        y: (b.y + c.y) / 2
      };
      const midCA = {
        x: (c.x + a.x) / 2,
        y: (c.y + a.y) / 2
      };

      // Создаем 4 новых треугольника
      const triangles = [
        { vertices: [a, midAB, midCA] },
        { vertices: [midAB, b, midBC] },
        { vertices: [midCA, midBC, c] },
        { vertices: [midAB, midBC, midCA] }
      ];

      // Заменяем исходный треугольник на 4 новых
      const index = shapes.indexOf(shape);
      shapes.splice(index, 1);
      
      triangles.forEach(triangle => {
        const newShape = new Shape(shape.x, shape.y, triangle.vertices);
        // Копируем свойства из исходной фигуры
        Object.assign(newShape, {
          color: shape.color,
          texture: shape.texture,
          textureImage: shape.textureImage,
          textureScale: shape.textureScale,
          textureRotation: shape.textureRotation,
          textureOffsetX: shape.textureOffsetX,
          textureOffsetY: shape.textureOffsetY,
          textureFlipX: shape.textureFlipX,
          textureFlipY: shape.textureFlipY
        });
        shapes.push(newShape);
      });
      
      render();
    }

    function render() {
      // Заливка фона вместо clearRect
      ctx.fillStyle = backgroundColorInput.value;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      if (backgroundImage) {
        ctx.globalAlpha = parseInt(imageOpacityInput.value) / 100;
        ctx.drawImage(backgroundImage, canvasOffsetX, canvasOffsetY);
        ctx.globalAlpha = 1;
      }
      
      drawSymmetryAxis();
      shapes.forEach(shape => shape.draw());
      
      if (selectionStart) {
        ctx.strokeStyle = '#0095ff';
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        ctx.strokeRect(
          selectionStart.x,
          selectionStart.y,
          lastMousePosition.x - selectionStart.x,
          lastMousePosition.y - selectionStart.y
        );
        ctx.setLineDash([]);
      }
    }

    // Сохранение изображений
    function saveAsSVG() {
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("width", canvas.width);
      svg.setAttribute("height", canvas.height);
      svg.setAttribute("viewBox", `0 0 ${canvas.width} ${canvas.height}`);
      
      // Добавляем изображение (если есть)
      if (backgroundImage) {
        const img = document.createElementNS("http://www.w3.org/2000/svg", "image");
        img.setAttribute("href", backgroundImage.src);
        img.setAttribute("width", canvas.width);
        img.setAttribute("height", canvas.height);
        img.setAttribute("opacity", parseInt(imageOpacityInput.value) / 100);
        img.setAttribute("x", canvasOffsetX);
        img.setAttribute("y", canvasOffsetY);
        svg.appendChild(img);
      }
      
      // Добавляем фигуры
      shapes.forEach(shape => {
        const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
        const points = shape.vertices.map(v => 
          `${shape.x + v.x},${shape.y + v.y}`
        ).join(" ");
        polygon.setAttribute("points", points);
        
        if (shape.texture && shape.textureImage) {
          // Для фигур с текстурой создаем pattern
          const pattern = document.createElementNS("http://www.w3.org/2000/svg", "pattern");
          const patternId = `pattern_${shape.id}`;
          pattern.setAttribute("id", patternId);
          pattern.setAttribute("patternUnits", "userSpaceOnUse");
          pattern.setAttribute("width", shape.textureImage.width * (shape.textureScale / 100));
          pattern.setAttribute("height", shape.textureImage.height * (shape.textureScale / 100));
          
          // Добавляем трансформации
          const transform = [];
          transform.push(`translate(${shape.textureOffsetX} ${shape.textureOffsetY})`);
          transform.push(`rotate(${shape.textureRotation} ${shape.textureImage.width * (shape.textureScale / 100) / 2} ${shape.textureImage.height * (shape.textureScale / 100) / 2})`);
          
          if (shape.textureFlipX || shape.textureFlipY) {
            transform.push(`scale(${shape.textureFlipX ? -1 : 1} ${shape.textureFlipY ? -1 : 1})`);
          }
          
          pattern.setAttribute("patternTransform", transform.join(' '));
          
          const image = document.createElementNS("http://www.w3.org/2000/svg", "image");
          image.setAttribute("href", shape.textureImage.src);
          image.setAttribute("width", shape.textureImage.width * (shape.textureScale / 100));
          image.setAttribute("height", shape.textureImage.height * (shape.textureScale / 100));
          
          pattern.appendChild(image);
          svg.appendChild(pattern);
          
          polygon.setAttribute("fill", `url(#${patternId})`);
        } else {
          polygon.setAttribute("fill", shape.color);
        }
        
        polygon.setAttribute("stroke", shape.isSelected ? '#ff0000' : strokeColorInput.value);
        polygon.setAttribute("stroke-width", strokeWidthInput.value);
        polygon.setAttribute("opacity", parseInt(mosaicOpacityInput.value) / 100);
        svg.appendChild(polygon);
      });
      
      const serializer = new XMLSerializer();
      let svgStr = serializer.serializeToString(svg);
      svgStr = '<?xml version="1.0" standalone="no"?>\n' + svgStr;
      
      const blob = new Blob([svgStr], {type: "image/svg+xml"});
      const url = URL.createObjectURL(blob);
      
      const link = document.createElement("a");
      link.href = url;
      link.download = "mosaic.svg";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    function saveAsPNG() {
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = canvas.width;
      tempCanvas.height = canvas.height;
      const tempCtx = tempCanvas.getContext('2d');
      
      // Рисуем фон
      tempCtx.fillStyle = backgroundColorInput.value;
      tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
      
      // Рисуем изображение (если есть)
      if (backgroundImage) {
        tempCtx.globalAlpha = parseInt(imageOpacityInput.value) / 100;
        tempCtx.drawImage(backgroundImage, canvasOffsetX, canvasOffsetY);
        tempCtx.globalAlpha = 1;
      }
      
      // Рисуем фигуры
      shapes.forEach(shape => {
        if (shape.texture && shape.textureImage) {
          tempCtx.save();
          
          // Создаем путь для фигуры
          tempCtx.beginPath();
          tempCtx.moveTo(shape.x + shape.vertices[0].x, shape.y + shape.vertices[0].y);
          for (let i = 1; i < shape.vertices.length; i++) {
            tempCtx.lineTo(shape.x + shape.vertices[i].x, shape.y + shape.vertices[i].y);
          }
          tempCtx.closePath();
          tempCtx.clip();
          
          // Вычисляем центр фигуры
          let centerX = 0, centerY = 0;
          shape.vertices.forEach(v => {
            centerX += shape.x + v.x;
            centerY += shape.y + v.y;
          });
          centerX /= shape.vertices.length;
          centerY /= shape.vertices.length;
          
          // Применяем трансформации к текстуре
          tempCtx.translate(centerX, centerY);
          tempCtx.rotate(shape.textureRotation * Math.PI / 180);
          
          // Вычисляем размеры текстуры с учетом масштаба
          const scale = shape.textureScale / 100;
          const width = shape.textureImage.width * scale;
          const height = shape.textureImage.height * scale;
          
          // Отражаем относительно центра фигуры
          if (shape.textureFlipX || shape.textureFlipY) {
            tempCtx.scale(
              shape.textureFlipX ? -1 : 1,
              shape.textureFlipY ? -1 : 1
            );
          }
          
          // Рисуем текстуру с учетом смещения
          tempCtx.globalAlpha = parseInt(mosaicOpacityInput.value) / 100;
          tempCtx.drawImage(
            shape.textureImage, 
            -width/2 + shape.textureOffsetX, 
            -height/2 + shape.textureOffsetY, 
            width, 
            height
          );
          
          tempCtx.restore();
        } else {
          tempCtx.globalAlpha = parseInt(mosaicOpacityInput.value) / 100;
          tempCtx.fillStyle = shape.color;
          tempCtx.beginPath();
          tempCtx.moveTo(shape.x + shape.vertices[0].x, shape.y + shape.vertices[0].y);
          for (let i = 1; i < shape.vertices.length; i++) {
            tempCtx.lineTo(shape.x + shape.vertices[i].x, shape.y + shape.vertices[i].y);
          }
          tempCtx.closePath();
          tempCtx.fill();
        }
        
        // Обводка
        if (shape.isSelected) {
          tempCtx.strokeStyle = '#ff0000';
        } else {
          tempCtx.strokeStyle = strokeColorInput.value;
        }
        tempCtx.lineWidth = strokeWidthInput.value;
        tempCtx.stroke();
        tempCtx.globalAlpha = 1;
      });
      
      const dataURL = tempCanvas.toDataURL("image/png");
      const link = document.createElement("a");
      link.href = dataURL;
      link.download = "mosaic.png";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    // Функция изменения размера
    function resizeCanvas(newWidth, newHeight) {
      const oldWidth = canvas.width;
      const oldHeight = canvas.height;
      
      canvasWidth = newWidth;
      canvasHeight = newHeight;
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      
      // Корректируем смещение изображения, чтобы оно оставалось в центре
      if (backgroundImage) {
        canvasOffsetX = (canvas.width - backgroundImage.width) / 2;
        canvasOffsetY = (canvas.height - backgroundImage.height) / 2;
      }
      
      // Корректировка позиций фигур относительно центра
      const dx = (canvas.width - oldWidth) / 2;
      const dy = (canvas.height - oldHeight) / 2;
      shapes.forEach(shape => {
        shape.x += dx;
        shape.y += dy;
      });
      
      render();
    }

    // Функция для переключения между панелями инструментов
    function showTextureTools() {
      toolsMain.style.display = 'none';
      toolsTexture.style.display = 'flex';
      canvasControls.style.display = 'none';
      
      // Обновляем значения контролов
      const selectedShapes = shapes.filter(s => s.isSelected && s.texture);
      if (selectedShapes.length > 0) {
        const firstShape = selectedShapes[0];
        textureScale.value = firstShape.textureScale;
        textureRotation.value = firstShape.textureRotation;
        textureOffsetX.value = firstShape.textureOffsetX;
        textureOffsetY.value = firstShape.textureOffsetY;
      }
    }
    
    function showMainTools() {
      toolsMain.style.display = 'flex';
      toolsTexture.style.display = 'none';
      canvasControls.style.display = 'flex';
    }

    // Обработчики событий
    uploadBtn.addEventListener('click', function() {
      imageUpload.click();
    });

    imageUpload.addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(event) {
        const img = new Image();
        img.onload = function() {
          backgroundImage = img;
          // Центрируем изображение
          canvasOffsetX = (canvas.width - img.width) / 2;
          canvasOffsetY = (canvas.height - img.height) / 2;
          
          // Обновляем интерфейс
          imageOpacityInput.value = 100;
          mosaicOpacityInput.value = 100;
          
          // Перерисовываем холст
          render();
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
      
      e.target.value = '';
    });

    applyCanvasSizeBtn.addEventListener('click', () => {
      const width = parseInt(canvasWidthInput.value);
      const height = parseInt(canvasHeightInput.value);
      if (width > 0 && height > 0) {
        resizeCanvas(width, height);
      }
    });

    backgroundColorInput.addEventListener('input', () => {
      render();
    });

    textureUpload.addEventListener('change', function(e) {
      const files = Array.from(e.target.files);
      if (files.length === 0) return;
      
      files.forEach(file => {
        textureManager.addTexture(file).then(texture => {
          const selectedShapes = shapes.filter(s => s.isSelected);
          if (selectedShapes.length > 0) {
            selectedShapes.forEach(shape => {
              shape.texture = texture.file;
              shape.textureImage = texture.img;
              shape.textureScale = 100;
              shape.textureRotation = 0;
              shape.textureOffsetX = 0;
              shape.textureOffsetY = 0;
              shape.textureFlipX = false;
              shape.textureFlipY = false;
            });
            
            textureScale.value = 100;
            textureRotation.value = 0;
            textureOffsetX.value = 0;
            textureOffsetY.value = 0;
            
            showTextureTools();
            render();
          }
        });
      });
      
      e.target.value = '';
    });

    colorFilter.addEventListener('change', updateTextureFilters);
    patternFilter.addEventListener('change', updateTextureFilters);
    textureSearch.addEventListener('input', updateTextureFilters);

    function updateTextureFilters() {
      textureManager.renderTextures({
        color: colorFilter.value,
        pattern: patternFilter.value,
        search: textureSearch.value
      });
    }

    textureScale.addEventListener('input', function() {
      shapes.filter(s => s.isSelected).forEach(shape => {
        if (shape.texture) {
          shape.textureScale = parseInt(this.value);
        }
      });
      render();
    });

    textureRotation.addEventListener('input', function() {
      shapes.filter(s => s.isSelected).forEach(shape => {
        if (shape.texture) {
          shape.textureRotation = parseInt(this.value);
        }
      });
      render();
    });

    textureOffsetX.addEventListener('input', function() {
      shapes.filter(s => s.isSelected).forEach(shape => {
        if (shape.texture) {
          shape.textureOffsetX = parseInt(this.value);
        }
      });
      render();
    });

    textureOffsetY.addEventListener('input', function() {
      shapes.filter(s => s.isSelected).forEach(shape => {
        if (shape.texture) {
          shape.textureOffsetY = parseInt(this.value);
        }
      });
      render();
    });

    flipTextureX.addEventListener('click', function() {
      shapes.filter(s => s.isSelected).forEach(shape => {
        if (shape.texture) {
          shape.textureFlipX = !shape.textureFlipX;
        }
      });
      render();
    });

    flipTextureY.addEventListener('click', function() {
      shapes.filter(s => s.isSelected).forEach(shape => {
        if (shape.texture) {
          shape.textureFlipY = !shape.textureFlipY;
        }
      });
      render();
    });

    resetTextureBtn.addEventListener('click', function() {
      shapes.filter(s => s.isSelected).forEach(shape => {
        if (shape.texture) {
          shape.textureScale = 100;
          shape.textureRotation = 0;
          shape.textureOffsetX = 0;
          shape.textureOffsetY = 0;
          shape.textureFlipX = false;
          shape.textureFlipY = false;
        }
      });
      
      textureScale.value = 100;
      textureRotation.value = 0;
      textureOffsetX.value = 0;
      textureOffsetY.value = 0;
      
      render();
    });

    removeTextureBtn.addEventListener('click', function() {
      shapes.filter(s => s.isSelected).forEach(shape => {
        delete shape.texture;
        delete shape.textureImage;
      });
      
      showMainTools();
      render();
    });

    imageOpacityInput.addEventListener('input', render);
    mosaicOpacityInput.addEventListener('input', render);

    symmetryBtn.addEventListener('click', function() {
      isSymmetryMode = !isSymmetryMode;
      this.classList.toggle('active', isSymmetryMode);
      render();
    });

    shapeSizeInput.addEventListener('input', render);
    strokeColorInput.addEventListener('input', render);
    strokeWidthInput.addEventListener('input', render);

    deleteSelectedBtn.addEventListener('click', () => {
      history.saveState();
      for (let i = shapes.length - 1; i >= 0; i--) {
        if (shapes[i].isSelected) {
          if (isSymmetryMode && symmetricPairs.has(shapes[i])) {
            const mirror = symmetricPairs.get(shapes[i]);
            shapes.splice(shapes.indexOf(mirror), 1);
            symmetricPairs.delete(mirror);
          }
          shapes.splice(i, 1);
        }
      }
      
      const hasTexturedSelection = shapes.some(s => s.isSelected && s.texture);
      if (!hasTexturedSelection) {
        showMainTools();
      }
      
      render();
    });

    undoBtn.addEventListener('click', () => {
      history.undo();
      render();
    });

    redoBtn.addEventListener('click', () => {
      history.redo();
      render();
    });

    saveSVGBtn.addEventListener('click', saveAsSVG);
    savePNGBtn.addEventListener('click', saveAsPNG);

    addTextureBtn.addEventListener('click', function() {
      textureUpload.click();
    });

    backToMainToolsBtn.addEventListener('click', showMainTools);

    canvas.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      
      clickedShape = null;
      for (let shape of shapes) {
        if (shape.contains(mouseX, mouseY)) {
          clickedShape = shape;
          break;
        }
      }
      
      if (clickedShape) {
        shapeContextMenu.style.display = 'block';
        shapeContextMenu.style.left = `${e.clientX}px`;
        shapeContextMenu.style.top = `${e.clientY}px`;
        contextMenu.style.display = 'none';
      } else {
        contextMenu.style.display = 'block';
        contextMenu.style.left = `${e.clientX}px`;
        contextMenu.style.top = `${e.clientY}px`;
        shapeContextMenu.style.display = 'none';
      }
      
      menuPosition = { x: mouseX, y: mouseY };
    });

    window.addEventListener('click', (e) => {
      if (e.target !== splitIntoTrianglesBtn && 
          e.target !== addTriangleBtn && 
          e.target !== addSquareBtn && 
          e.target !== addHexagonBtn &&
          e.target !== addTextureToShapeBtn &&
          e.target !== splitIntoSimilarBtn) {
        contextMenu.style.display = 'none';
        shapeContextMenu.style.display = 'none';
      }
    });

    splitIntoTrianglesBtn.addEventListener('click', () => {
      if (clickedShape) {
        splitShapeIntoTriangles(clickedShape, menuPosition.x, menuPosition.y);
      }
      shapeContextMenu.style.display = 'none';
    });

    splitIntoSimilarBtn.addEventListener('click', () => {
      if (clickedShape) {
        splitIntoSimilarTriangles(clickedShape);
      }
      shapeContextMenu.style.display = 'none';
    });

    addTextureToShapeBtn.addEventListener('click', () => {
      if (clickedShape) {
        const activeThumb = document.querySelector('.texture-thumb.active');
        if (activeThumb) {
          const textureFile = activeThumb.querySelector('img').dataset.texture;
          const texture = textureManager.getTextureByName(textureFile);
          
          if (texture) {
            clickedShape.texture = texture.file;
            clickedShape.textureImage = texture.img;
            clickedShape.textureScale = 100;
            clickedShape.textureRotation = 0;
            clickedShape.textureOffsetX = 0;
            clickedShape.textureOffsetY = 0;
            clickedShape.textureFlipX = false;
            clickedShape.textureFlipY = false;
            
            textureScale.value = 100;
            textureRotation.value = 0;
            textureOffsetX.value = 0;
            textureOffsetY.value = 0;
            
            showTextureTools();
          }
        }
      }
      shapeContextMenu.style.display = 'none';
      render();
    });

    function addShape(verticesGenerator) {
      history.saveState();
      const size = parseInt(shapeSizeInput.value);
      if (isSymmetryMode) {
        createSymmetricPair(menuPosition.x, menuPosition.y, verticesGenerator(size));
      } else {
        shapes.push(new Shape(menuPosition.x, menuPosition.y, verticesGenerator(size)));
      }
      contextMenu.style.display = 'none';
      render();
    }

    addTriangleBtn.addEventListener('click', () => addShape(generateTriangleVertices));
    addSquareBtn.addEventListener('click', () => addShape(generateSquareVertices));
    addHexagonBtn.addEventListener('click', () => addShape(generateHexagonVertices));

    canvas.addEventListener('mousedown', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      lastMousePosition = { x: mouseX, y: mouseY };

      if (e.button === 0 && !e.ctrlKey && !e.altKey) {
        let clickedOnShape = false;
        for (let shape of shapes) {
          if (shape.contains(mouseX, mouseY) || shape.hitTestVertex(mouseX, mouseY) !== null) {
            clickedOnShape = true;
            break;
          }
        }
        
        if (!clickedOnShape) {
          shapes.forEach(shape => shape.isSelected = false);
          showMainTools();
          render();
          return;
        }
      }
      
      if (e.altKey && e.button === 0) {
        history.saveState();
        for (let shape of shapes) {
          const vertexIndex = shape.hitTestVertex(mouseX, mouseY);
          if (vertexIndex !== null && shape.vertices.length > 3) {
            shape.vertices.splice(vertexIndex, 1);
            if (isSymmetryMode && symmetricPairs.has(shape)) {
              const mirror = symmetricPairs.get(shape);
              mirror.vertices.splice(vertexIndex, 1);
            }
            render();
            return;
          }
        }
      }
      
      if (e.detail === 2 && e.button === 0) {
        history.saveState();
        for (let shape of shapes) {
          const edge = shape.hitTestEdge(mouseX, mouseY);
          if (edge) {
            shape.vertices.splice(edge.edgeIndex + 1, 0, edge.position);
            if (isSymmetryMode && symmetricPairs.has(shape)) {
              const mirror = symmetricPairs.get(shape);
              const mirroredPosition = { x: -edge.position.x, y: edge.position.y };
              mirror.vertices.splice(edge.edgeIndex + 1, 0, mirroredPosition);
            }
            render();
            return;
          }
        }
      }

      if (e.button !== 0) return;

      if (e.button === 0 && e.ctrlKey) {
        selectionStart = { x: mouseX, y: mouseY };
        return;
      }

      let anyVertexClicked = false;
      
      for (let shape of shapes) {
        const vertexIndex = shape.hitTestVertex(mouseX, mouseY);
        if (vertexIndex !== null) {
          if (!e.ctrlKey) {
            shapes.forEach(s => s.isSelected = false);
            showMainTools();
          }
          
          dragMode = 'vertex';
          shape.isDragging = true;
          shape.dragVertex = vertexIndex;
          activeShape = shape;
          shape.isSelected = true;
          anyVertexClicked = true;
          
          const connectedVertices = findConnectedVertices(shape, vertexIndex);
          
          connectedVertices.forEach(({shape: connectedShape, vertexIndex: connectedIndex}) => {
            connectedShape.vertexOffsets = connectedShape.vertexOffsets || {};
            connectedShape.vertexOffsets[connectedIndex] = {
              x: mouseX - (connectedShape.x + connectedShape.vertices[connectedIndex].x),
              y: mouseY - (connectedShape.y + connectedShape.vertices[connectedIndex].y)
            };
          });
          
          break;
        }
      }
      
      if (anyVertexClicked) return;

      for (let shape of shapes) {
        if (shape.contains(mouseX, mouseY)) {
          dragMode = 'shape';
          shape.isDragging = true;
          activeShape = shape;
          
          if (!shape.isSelected && !e.ctrlKey) {
            shapes.forEach(s => s.isSelected = false);
            showMainTools();
          }
          shape.isSelected = true;
          
          shape.offsetX = mouseX - shape.x;
          shape.offsetY = mouseY - shape.y;
          
          if (shape.texture) {
            showTextureTools();
            textureScale.value = shape.textureScale;
            textureRotation.value = shape.textureRotation;
            textureOffsetX.value = shape.textureOffsetX;
            textureOffsetY.value = shape.textureOffsetY;
          }
          
          render();
          return;
        }
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      lastMousePosition = { x: mouseX, y: mouseY };

      if (selectionStart && ctrlPressed) {
        render();
        return;
      }

      if (!activeShape || !dragMode) return;

      if (dragMode === 'vertex' && activeShape.dragVertex !== null) {
        activeShape.vertices[activeShape.dragVertex].x = mouseX - activeShape.x;
        activeShape.vertices[activeShape.dragVertex].y = mouseY - activeShape.y;
        
        shapes.forEach(shape => {
          if (shape.vertexOffsets) {
            Object.keys(shape.vertexOffsets).forEach(index => {
              const offset = shape.vertexOffsets[index];
              shape.vertices[index].x = mouseX - offset.x - shape.x;
              shape.vertices[index].y = mouseY - offset.y - shape.y;
            });
          }
        });
        
        if (isSymmetryMode && symmetricPairs.has(activeShape)) {
          const mirror = symmetricPairs.get(activeShape);
          const axisX = canvas.width / 2;
          const mirroredX = 2 * axisX - mouseX;
          
          mirror.vertices[activeShape.dragVertex].x = mirroredX - mirror.x;
          mirror.vertices[activeShape.dragVertex].y = mouseY - mirror.y;
        }
        
        snapVertices(activeShape);
      } else if (dragMode === 'shape') {
        const dx = mouseX - activeShape.offsetX - activeShape.x;
        const dy = mouseY - activeShape.offsetY - activeShape.y;
        
        shapes.forEach(shape => {
          if (shape.isSelected) {
            shape.x += dx;
            shape.y += dy;
            
            if (isSymmetryMode && symmetricPairs.has(shape)) {
              const mirror = symmetricPairs.get(shape);
              mirror.x = canvas.width - shape.x;
              mirror.y = shape.y;
            }
          }
        });
      }
      
      render();
    });

    canvas.addEventListener('mouseup', (e) => {
      shapes.forEach(shape => {
        if (shape.vertexOffsets) {
          delete shape.vertexOffsets;
        }
      });
      
      if (selectionStart) {
        if (ctrlPressed) {
          const rect = canvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          
          const x1 = Math.min(selectionStart.x, mouseX);
          const y1 = Math.min(selectionStart.y, mouseY);
          const x2 = Math.max(selectionStart.x, mouseX);
          const y2 = Math.max(selectionStart.y, mouseY);
          
          shapes.forEach(shape => {
            const isInSelection = (
              shape.x >= x1 && shape.x <= x2 &&
              shape.y >= y1 && shape.y <= y2
            );
            
            if (e.ctrlKey) {
              if (isInSelection) shape.isSelected = true;
            } else {
              shape.isSelected = isInSelection;
            }
          });
          
          const hasTexturedSelection = shapes.some(s => s.isSelected && s.texture);
          if (hasTexturedSelection) {
            showTextureTools();
          } else {
            showMainTools();
          }
        }
        
        selectionStart = null;
        render();
      }
      
      if (activeShape) {
        if (dragMode === 'vertex' || dragMode === 'shape') {
          history.saveState();
        }
        
        activeShape.isDragging = false;
        activeShape.dragVertex = null;
        activeShape = null;
      }
      dragMode = null;
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Delete') {
        deleteSelectedBtn.click();
      }
      
      if (e.key === 'Control') {
        ctrlPressed = true;
      }
      
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        const step = e.shiftKey ? 10 : 1;
        let moved = false;
        
        shapes.forEach(shape => {
          if (shape.isSelected) {
            if (e.key === 'ArrowUp') shape.y -= step;
            if (e.key === 'ArrowDown') shape.y += step;
            if (e.key === 'ArrowLeft') shape.x -= step;
            if (e.key === 'ArrowRight') shape.x += step;
            moved = true;
            
            if (isSymmetryMode && symmetricPairs.has(shape)) {
              const mirror = symmetricPairs.get(shape);
              mirror.x = canvas.width - shape.x;
              mirror.y = shape.y;
            }
          }
        });
        
        if (moved) {
          history.saveState();
          render();
        }
      }
      
      if (e.ctrlKey) {
        if (e.key === 'z') {
          e.preventDefault();
          history.undo();
          render();
        } else if (e.key === 'y') {
          e.preventDefault();
          history.redo();
          render();
        } else if (e.key === 's') {
          e.preventDefault();
          saveAsSVG();
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      if (e.key === 'Control') {
        ctrlPressed = false;
        if (selectionStart) {
          selectionStart = null;
          render();
        }
      }
    });

    // Инициализация
    history.saveState();
    render();
    showMainTools();
  </script>
</body>
</html>